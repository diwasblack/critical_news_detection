\chapter{Genetic Algorithm}
\label{ch:background}

%\section{Overview} \label{sec:GA-overview}



\section{Logistics of Operation} \label{sec:GA-logistics}
Our method accepts an MS Excel file with pre-specified headers and datatypes. Then it eliminates all duplicate elements and combines cations and anions of salts and precipitants. 
This set of elements is taken as the initial population for genetic algorithm and subsequent generations will be derived from this population. After successfully reading and preprocessing data, the program applies selection, crossover, and mutation for certain number of iterations to generate next generation of population of cocktails. Once the final population is retrieved, this result is optimized by removing duplicates, generating concentrations and sorting the candidate cocktails on the basis of their rank.
A flowchart of the whole process is shown in \figureref{fig:flow}.


\begin{figure}[H]
	\cfig{2}{flowchart.png}{5}
	\caption{Flowchart}
	\label{fig:flow}
\end{figure}



We first explain the dataset and then explain the genetic algorithm. Understanding the dataset helps understand the structure of a chromosome used in genetic algorithm. The main steps in a genetic algorithm are genetic representation, selection, crossover, and mutation.
After explaining the genetic algorithm,  we describe the fitness function in more detail.


\section{Dataset} \label{sec:GA-dataset}

The dataset used for this research is a screen file containing a list of cocktail conditions in a spreadsheet in MS Excel format. The headers (columns) present in the screen file are \textit{`Well\_Id', `B\_Anion', `B\_Cation', `Ph', `B\_Conc', `C1\_Anion', `C1\_Cation', `C1\_Conc', `C1\_M', `C1\_Ph', `C2\_Anion', `C2\_Cation', `C2\_Conc', `C2\_M', `C2\_Ph', `C3\_Anion', `C3\_Cation', `C3\_Conc', `C3\_M', `C3\_Ph', `C4\_Anion', `C4\_Cation', `C4\_Conc', `C4\_M', `C4\_Ph', `C5\_Anion', `C5\_Cation', `C5\_Conc', `C5\_M', `C5\_Ph', `S\_a', `S\_b',} and \textit{`S\_c'}. Each header represents a property of the cocktail. The screen file used in our research accommodates a total of six reagents: a buffer, a precipitant, and four salts or additive reagents. A partial dataset is shown in \figureref{fig:dataset}.

\begin{figure}[H]
	\cfig{2}{dataset.PNG}{5}
	\caption{Dataset}
	\label{fig:dataset}
\end{figure}

`Well\_id' is an identifier of the cocktail and also indicates the row and column position of the condition in the experiment plate. The next header names can be divided into a reagent type followed by its property separated by an underscore. There are 6 reagent groups: \textit{B, C1, C2, C3, C4, C5}. Column B refers to the buffer reagent, C1 is the precipitant, and C2, C3, C4 and C5 are additives which can be salts or precipitants. The combination of `anion' and `cation' forms a chemical. For example, a buffer name is a concatenation of columns `B\_Cation' and `B\_Anion'. The anion column contains the negatively charged ion, and the cation column contains the positively charged ion. Not all chemicals can be clearly separated into cations and anions like polymers, detergents, organic compounds etc. In such cases, the chemical name resides in the `Anion' column. The properties `M' and `Conc' refers to the concentration of the chemicals. If a chemical has concentration in unit of molar (M), its value resides in the `M' column, other unit values such as percent weight per volume (\%w/v) and percent volume per volume (\%v/v) reside in the `Conc' column. The `Ph' column contains the pH value of the reagent. The last three columns contain the scores of the cocktail generated by the result of the experiments in the wet lab. `S\_a', `S\_b', `S\_c' are the scores of the cocktail drop having \textit{protein:precipitant} ratios 1:1, 2:1 and 4:1 respectively and their values are in the range [0,9] \cite{OptimizeAED}. The scores are used to filter the cocktails used in the algorithm and to determine the score of the newly generated solutions.


\section{Stages of Genetic Algorithm} \label{sec:GA-stages}

In our case, an individual is a single cocktail made up of 3 genes -- buffer (pH value), precipitant (cation + anion), and  salt (cation + anion). Each individual represents a chromosome. The dataset is represented as:

\begin{equation}
Dataset = \{(I_{i}, S_{i}) |(I_{1},S_{1}), (I_{2},S_{2}), ..., (I_{n},S_{n}) ) \} \label{eq}
\end{equation}

\noindent
where the pair $(I_{i}, S_{i})$ represents the $i^{th}$ individual (or cocktail in this context) $I_{i}$ with its score $S_{i}$. Further, each individual is represented as:

\begin{equation}
I_{i} = \{ pH_{i}, P_{i}, S_{i} \} \label{eq}
\end{equation}

\noindent
where $pH_{i}$, $P_{i}$, and $S_{i}$ represent the pH, precipitant, and salt of the $i^{th}$ individual respectively. These values can be empty as well.

The next 3 steps are performed iteratively one after another  for a certain number of generations.

\subsection{Selection} \label{sec:GA-selection}
Selection method aims to choose two fit individuals as parents from the current generation. For each parent, a sample size of certain individuals are chosen randomly and the fittest individual among them is selected. For example, if there are 100 individuals in the population, a subset of 5 individuals is chosen, and the one with highest fitness score is selected as the first parent. This selection process is repeated to select the second parent as well. This method of selection is commonly known as tournament selection. 

%\begin{equation}
%Tournament(T) = \{ c:c \in C, C \subset N \thinspace and \thinspace  \forall c \in C, P(c) = 1/|N| \thinspace and \thinspace |C| = k \} \label{eq}
%\end{equation}

%where $N$ is the population, $C$ is a set of cocktails, $P(c)$ is the probability of occurrence of $c$, and $k$ is the tournament size.

\begin{equation}
Fittest(c_{f}) = \{ c_{f}| c_{f} \in T \thinspace and \thinspace (\forall c) (\thinspace c \in T \rightarrow f_{c_{f}} >= f_{c} \thinspace  ) \} \label{eq}
\end{equation}

\noindent
where $T$ is the tournament and $f_{c}$ is the fitness score for cocktail $c$.


\subsection{Crossover} \label{sec:GA-crossover}
Crossover is the process of intermixing genes from fit parents to produce children for the next generation. A single crossover point is chosen such that the left side of this point inherits genes from the first parent and the right side inherits from the second parent. For example, consider the following $Parent_{1}$ and $Parent_{2}$: 

\begin{equation}
Parent_{1} = \{ pH_{1}, P_{1}, S_{1} \} \label{eq}
\end{equation}
\begin{equation}
Parent_{2} = \{ pH_{2}, P_{2}, S_{2} \} \label{eq}
\end{equation}

$Parent_{1}$ and $Parent_{2}$ are the parent individuals obtained from the selection process described in the previous subsection. Then a random crossover point is chosen in the range of $[0, gene\_length-1]$. In our case, $gene\_length = 3$. For example, if the crossover point is selected as 1, then the child will get the first gene from the first parent, and rest other genes from the second parent as follows:


\begin{equation}
Child = \{ pH_{1}, P_{2}, S_{2} \} \label{eq}
\end{equation}

\subsection{Mutation} \label{sec:GA-mutation}
It is the probability of applying a random change in the genes of an individual. For each gene of the child chromosome, a random number is generated between 0 and 1. Mutation is introduced to that gene only if the generated random number is smaller than the mutation rate.

Lets assume that the mutation rate is 0.3 and that mutation is applied only for the second gene.  $Child$ obtained from crossover described in the previous subsection then becomes

\begin{equation}
Child = \{ pH_{1}, P_{k}, S_{2} \} \label{eq}
\end{equation}

\noindent
where $P_{k}$ is the precipitant of $k^{th}$ individual from the population. $Child$ now has a gene from the original dataset that is different from both of its parents gene, thereby introducing a variation.

\section{Fitness Function and Novelty Search} \label{sec:GA-fitnessScore}

Fitness function is a type of objective function used mostly in genetic algorithms. It measures how fit a candidate solution (or individual) is with respect to the objective. Based on this measurement, the candidate is either rewarded or discarded. Unfortunately, it is not possible to determine the fitness of a candidate cocktail unless the cocktail solution is experimented in a wet lab. Our goal is actually to find the candidate solutions to be tested in the wet lab. One way to build a fitness function is to compute significance of each chemical by analyzing whether the outcome is better in its presence or not. 

GenScreen used significance ratio 
\cite{OptimizeAED} to calculate the fitness score. Significance ratio of a reagent is the ratio of the average score of cocktails having that reagent vs. the average score of cocktails without that reagent\cite{SamyamThesis}.
First, the significance score of each reagent is calculated. Then, the average significance scores  of these reagents in a cocktail are used to compute the fitness score of a cocktail.

This thesis uses a novel approach of calculating fitness score to explore the chemical space. Unlike GenScreen, we never use some sort of measurement to find out if the candidate solutions are closer to some ultimate goal or not. Instead of aiming for progress, we simply reward individuals that are different. To implement this, two important changes are performed. The first is to replace the fitness function with the novelty metric. Novelty metric is the average distance to the k-nearest neighbors of an individual in search space in the current population as well as previous populations (archive). This becomes the novelty of an individual. The second change is to have a history of highly novel individuals. Since the purpose of the algorithm is to find novel individuals that are different from the ones already seen by the algorithm, it is intuitive to take into account a history of all intermediate individuals encountered by the algorithm.

%The novelty metric calculation happens in two steps. The first step is to calculate each individual's distance to all other individuals in the population and individuals in the archive (individuals from previous populations). And the second step is to calculate the average distance to k-nearest neighbours, which in turn is assigned as the novelty of that individual. These steps are further explained in the following sections.

\subsection{Distance Calculation} \label{sec:GA-fitness-k}

Common proximity measures such as Euclidean distance and cosine similarity are not appropriate for quantitative measurement of the difference between two cocktails. %Euclidean distance, though easier to implement, cannot be used. 
A suitable distance measure that gives meaningful distance between samples must be used in any optimization algorithm.
In this thesis, we need to measure the distance between two cocktails. Hence, we use cocktail distance coefficient (CD coefficient) developed by Newman et al.\cite{Newman} as the distance measure. CD coefficient is particularly effective because it incorporates the actual chemical structure and concentration of chemicals in it. 

Each cocktail $C$ consists of buffer name, its concentration, its pH value, salt name, its concentration, precipitant name, and its concentration. A small change in any of these can have significant effects on the outcome. Instead of taking these values directly as features, extended-connectivity fingerprint (ECFP) for each cocktail is calculated and used to build a feature vector as suggested for CD coefficient computation. ECFPs are topological fingerprints and provide different molecular features including stereochemical information \cite{Newman}. The cocktail fingerprint $F_{k}$ is a summation of the features of each component scaled by their molar concentrations \cite{Newman}:

\begin{equation}
F_{k} = \sum_{i=1}^{n}f_{ik}[c_{i}]\label{eq}
\end{equation}

\noindent
where $f_{ik}$ is the frequency count descriptor $k$ from the ECFP component of the $i^{th}$ component of cocktail, [$c_{i}$] is the molar concentration of the $i^{th}$ component of cocktail.

Bray-Curtis dissimilarity measure is then used to calculate the distance between two cocktail fingerprints as suggested in \cite{Newman}. Its value ranges from 0 to 1, 0 meaning that the cocktail fingerprints are identical.

\begin{equation}
BC(F_{i},F_{j}) = \sum_{k}^{ } |F_{ik}-F_{jk}| / \sum_{k}^{ } |F_{ik}+F_{jk}|\label{eq}
\end{equation}

Finally, the $CD_{coeff}$ is used to measure the distance between two cocktails:
\begin{equation}
CD\displaystyle _{coeff} = \frac{1}{sum(w)} \left ( \left ( \frac{|E(pH_{i})-E(pH_{j})|}{14} \right )w_{1} + BC(F_{i},F_{j})w_{2}) \right )
\label{eq}
\end{equation}

\noindent
where $w = w_{1}, w_{2}  >= 0$ are weights, sum(w) $>$ 0, and $E(pH_{i})$ is an estimate of the pH in condition $i$ with a maximum value of 14. For simplicity, the values of weights are set as $w_{1}$ = $w_{2}$ = 1.0.

One problem we faced was the differences in the naming convention of the chemicals of the library and the chemicals in our screens. This created a difficulty in getting fingerprints for certain chemicals because the library could not find those names in its small database. To solve this problem we had to manually change the names of the chemicals. For example, hepes-na was changed to hepes sodium, peg 3350 to polyethylene glycol 3350, and many others.


\subsection{Novelty score calculation and the choice of optimal k} \label{sec:GA-fitness-k}
After we compute the distance among all cocktails, the fitness score or the novelty score for each cocktail is set as the average of the distances to its k-nearest neighbors. If this distance is large, the cocktail can intuitively be said to be in a sparse area of the chemical space. Conversely, it can be said to be in a dense area if the average distance is small \cite{Novelty}. The novelty score $\gamma$ for a cocktail x is given by:

\begin{equation}
\gamma (x) = \frac{1}{k}\sum_{i=0}^{k}CD_{coeff}(x,\mu_{i})\label{eq}
\end{equation}

\noindent
where $\mu_{i}$ is the $i^{th}$-nearest neighbour of x with respect to the distance metric \textit{$CD_{coeff}$}.

Choosing the optimal value of $k$ is important for utilizing k-nearest neighbour properly. We ran several trials of the algorithm for the protein AbIPP using different values of $k$ to see how it affects the result. The resulting values shown in \tableref{optimal_k} are average values of three such trials. We found out that there are more distinct families and high scoring cocktails when using $k=5$ and $k=10$ than when using $k=20$. %This is shown in \tableref{optimal_k}. 

\begin{table}[htbp]
\begin{center}

\caption{Calculation of the optimal value for k}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{k} & \textbf{Distinct Families} & \textbf{Top Score} & \textbf{Top 10 Mean Score}  \\
\hline
\textbf{5} & 137 & 2.72 & 2.65  \\
\hline
\textbf{10} & 132 & 2.72 &  2.62 \\
\hline
\textbf{20} & 128 & 2.60 &  2.57 \\
\hline
\end{tabular}
\label{optimal_k}

\end{center}
\end{table}

Since, the results for $k=5$ and $k=10$ are almost similar, we did further analysis as shown in \tableref{abipp_k} and \tableref{kpipp_k} to choose the optimal value of $k$. We observed the effect of $k$ on  different values of $population\_size$ and found out that there is not much difference. For our experiments, we used $k=10$ as the optimal one.

\begin{table}[htbp]
\begin{center}

\caption{Effect of k for the protein AbIPP}
\begin{tabular}{|c|c|c|c|c|}
\hline
  & \textbf{(k=5)} & \textbf{(k=10)} & \textbf{(k=5)} & \textbf{(k=10)} \\
\textbf{Population Size} & \textbf{Top 10} & \textbf{Top 10} & \textbf{\# Distinct} & \textbf{\# Distinct} \\
 & \textbf{Mean Score} & \textbf{Mean Score} & \textbf{Families} & \textbf{Families} \\
\hline
\textbf{100}& 2.72 & 2.72 & 72 &  76 \\
\hline
\textbf{150}& 2.72 & 2.62 & 90 &  97 \\
\hline
\textbf{200}& 2.62 & 2.72 & 128 &  118 \\
\hline
\textbf{250}& 2.72 & 2.72 & 172 &  167 \\
\hline
\end{tabular}
\label{abipp_k}

\end{center}
\end{table}

\begin{table}[htbp]
\begin{center}

\caption{Effect of k  for the protein KpIPP}
\begin{tabular}{|c|c|c|c|c|}
\hline
  & \textbf{(k=5)} & \textbf{(k=10)} & \textbf{(k=5)} & \textbf{(k=10)} \\
\textbf{Population Size} & \textbf{Top 10} & \textbf{Top 10} & \textbf{\# Distinct} & \textbf{\# Distinct} \\
 & \textbf{Mean Score} & \textbf{Mean Score} & \textbf{Families} & \textbf{Families} \\
\hline
\textbf{100}& 1.19 & 1.31 & 72 &  69 \\
\hline
\textbf{150}& 1.54 & 1.54 & 95 &  97 \\
\hline
\textbf{200}& 1.28 & 1.45 & 135 &  129 \\
\hline
\textbf{250}& 1.48 & 1.54 & 162 &  158 \\
\hline
\end{tabular}
\label{kpipp_k}

\end{center}
\end{table}

\section{Optimization of Results}\label{sec:GA-optimization}

A set of optimization steps is applied to the list of generated candidate cocktails. Any duplicate candidates are gotten rid of. Then, concentrations of reagents are added and candidates are prioritized on the basis of their ranks. This is done to ensure the efficiency of the output conditions. These candidate conditions are then recommended to be tested in the wet lab.

The generated conditions often have duplicate conditions. These conditions are identified and removed. Also, there might be some repetitive conditions - conditions that were already present in the input file. Such conditions are eliminated as well.

After the unique list of candidate cocktails is obtained, 3 different variations of the each cocktail is made  by varying the concentration of the additive reagent. A cocktail with buffer B, precipitant P, and additive S would have at least three different solutions with varying concentrations of S\cite{OptimizeAED,SamyamThesis}. The highest concentration for S from the input file is selected as the first concentration of S. The next two concentrations are typically obtained by reducing the initial concentration by 20-25\% successively\cite{OptimizeAED,SamyamThesis}. On the other hand, the concentration of buffer and precipitant are kept constant at 0.1M and 0.2M respectively\cite{OptimizeAED,SamyamThesis}.

After this step, a ranking mechanism is employed to sort the generated candidate cocktails on the basis of their likelihood to generate crystalline conditions. This makes it easier for lab personnel to select the cocktails that were ranked higher than others for wet lab experiments. It should be noted that the actual score of a condition cannot be known without setting it up in the wet lab and observing the result. Because of this, we had to come up with a scoring mechanism that would utilize actual scores of conditions already tested in the lab. We analyzed AED and decided to use \textit{significance ratio} to calculate scores for individual reagents and then average the individual scores to obtain the rank for a given candidate cocktail\cite{OptimizeAED}.

The reagent score of a precipitant $P$ according to AED is calculated as\cite{OptimizeAED}:
\begin{equation}
\rho(\delta_{p}) = \frac{\mu(\delta_{p})}{\mu(\Delta - \delta_{p})}
\label{eq}
\end{equation}

\noindent
where $\mu(\delta_{p})$ is the average score of all cocktails containing precipitant $P$ and $\mu(\Delta - \delta_{p})$ is the average score of all cocktails not containing precipitant $P$.

The rank of a cocktail is the average value of the significance ratio of its individual regents (buffer, precipitant, and salt). It is not to be confused with the fitness score (novelty metric) for that cocktail. Significance ratio is used instead of novelty metric for ranking because significance ratio is directly related to the actual score of the cocktail.

\begin{equation}
RankScore_{i} = \frac{\rho(\delta_{b}) + \rho(\delta_{p}) + \rho(\delta_{s})}{3}
\label{eq}
\end{equation}

\noindent
where $i$ is the index of cocktail in the dataset, $\rho(\delta_{b})$ is the significance ratio of its buffer, $\rho(\delta_{p})$ is the significance ratio of its precipitant, and $\rho(\delta_{s})$ is the significance ratio of its salt\cite{OptimizeAED}.

Finally, the candidate cocktails are sorted from the highest rank score to the lowest one and output the result in a file. 


\section{Optimization of the Running Time}\label{sec:GA-runtime}

The running time of the algorithm is highly affected by the calculation of the fitness score. Fitness score of a cocktail is the average chemical distance of that cocktail with all other cocktails in the population archive. This distance needs to be calculated among every cocktail of all subsequent generations. As mentioned in the previous section, we need to calculate the feature vector or fingerprint of each cocktail in the population. Then this feature vector is used to calculate the distance between two cocktails.

The vector of a chemical or a cocktail is unique and needs to be calculated only once per run. The calculation of the vector for a cocktail, in turn, utilizes the feature vector of the chemicals it is composed of. It is to be noted that there lies a large overhead in calculating these vectors for every chemicals and cocktails over and over again. One solution is to devise a combination of data structures and algorithms that can minimize the overhead by reusing the vectors already encountered by the algorithm.

We have a fixed number of chemicals in our database. So, to reduce the overhead, vectors for all these chemicals calculated and the program was preloaded with it. The effects of incorporating these techniques are further described below.


\subsection{Time complexity before optimization}\label{sec:GA-runtime-initial-bigO}

%The runtime largely depends upon the calculation of the cocktail distances which in turn depends on the computation of feature vectors of chemicals and cocktails.

Let us assume that the population size is 4. This means that 4 additional cocktails show up every generation. As shown in \tableref{iteration_1_methodology_table}, the cocktails in initial population are - A, B, C, and D. We need to calculate the distance between each cocktail and select the ones which are further away from all  other cocktails. %The scenario after the first generation is shown in \tableref{iteration_1_methodology_table} and  \tableref{iteration_1_methodology_table2}.

\begin{table}[htbp]
\begin{center}
\caption{Calculation of distances in the $1^{st}$ iteration}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
 & \textbf{A} & \textbf{B} & \textbf{C} & \textbf{D} & \textbf{Total} \\
\hline
\textbf{A} &  & $Dist_{1}$ & $Dist_{2}$ & $Dist_{3}$ & 3 \\
\hline
\textbf{B} & & & $Dist_{4}$ & $Dist_{5}$ & 2 \\
\hline
\textbf{C} &  &  &  & $Dist_{6}$ & 1 \\
\hline
\textbf{D} &  &  &  &   & 0 \\
\hline
\textbf{Total} & 0 & 1 & 2 & 3 & 6 \\
\hline
\end{tabular}
\label{iteration_1_methodology_table}
\end{center}
\end{table}

As shown in \tableref{iteration_1_methodology_table}, the total number of distance calculation is 3, 2, and 1 for A, B, and C respectively leading  to 6 distance calculations. Furthermore, the distance metric formula relies on the feature vector of the cocktails involved. 

\begin{table}[htbp]
\begin{center}
\caption{Calculation of feature vectors of cocktails in $1^{st}$ iteration}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
 & \textbf{A} & \textbf{B} & \textbf{C} & \textbf{D} & \textbf{Total} \\
\hline
\textbf{A} & & $F_{A}$, $F_{B}$ & $F_{A}$, $F_{C}$ & $F_{A}$, $F_{D}$ & 6 \\
\hline
\textbf{B} & & & $F_{B}$, $F_{C}$ & $F_{B}$, $F_{D}$ & 4 \\
\hline
\textbf{C} &  &  &  & $F_{C}$, $F_{D}$ & 2 \\
\hline
\textbf{D} &  &  &  &   & 0 \\
\hline
\textbf{Total} & 0 & 2 & 4 & 6 & 12 \\
\hline
\end{tabular}
\label{iteration_1_methodology_table2}
\end{center}
\end{table}

As shown in \tableref{iteration_1_methodology_table2}, the feature vectors $F_{A}$ and $F_{B}$ of cocktails A and B need to be computed respectively while calculating $Dist_{1}$. Similarly, feature vectors $F_{A}$ and $F_{C}$ need to be calculated for $Dist_{2}$. 
%Note that $F_{A}$ is calculated 3 times. 
This process is repeated for all other distances.
 


%Again, the feature vectors $F_{A}$ and $F_{B}$ of cocktails A and B in turn depends on the feature vectors of the chemicals it is composed of.


The feature vector of a cocktail is generated with the help of the  vectors of its chemicals. In \tableref{iteration_1_methodology_table3}, $f_{A_{P}}$ is the feature vector of the precipitant of  cocktail A and $f_{A_{S}}$ is the feature vector of the salt of  cocktail A and so on.  In our case the gene length($g$) is 3, i.e. an individual is composed  of 3 genes (pH , precipitant, and salt). Only the feature vectors of respective precipitant and salt need to be calculated because pH is just a numeric value.


\begin{table}[htbp]
\begin{center}
\caption{Calculation of feature vectors of chemicals in 1st Iteration}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
 & \textbf{A} & \textbf{B} & \textbf{C} & \textbf{D} & \textbf{Total} \\
\hline
\textbf{A} & & $f_{A_{P}}$, $f_{A_{S}}$ , $f_{B_{P}}$, $f_{B_{S}}$  & $f_{A_{P}}$, $f_{A_{S}}$ , $f_{C_{P}}$, $f_{C_{S}}$  & $f_{A_{P}}$, $f_{A_{S}}$ , $f_{D_{P}}$, $f_{D_{S}}$  & 12 \\
\hline
\textbf{B} & & & $f_{B_{P}}$, $f_{B_{S}}$ , $f_{C_{P}}$, $f_{C_{S}}$  & $f_{B_{P}}$, $f_{B_{S}}$ , $f_{D_{P}}$, $f_{D_{S}}$  & 8 \\
\hline
\textbf{C} &  &  &  & $f_{C_{P}}$, $f_{C_{S}}$ , $f_{D_{P}}$, $f_{D_{S}}$  & 4 \\
\hline
\textbf{D} &  &  &  &   & 0 \\
\hline
\textbf{Total} & 0 & 4 & 8 & 12 & 24 \\
\hline
\end{tabular}
\label{iteration_1_methodology_table3}
\end{center}
\end{table}



In this way, the first iteration is performed. Then for the next iteration, 4 more cocktails - E, F, G, and H are added to the population archive. The distances of each these cocktails are calculated among themselves and all prior cocktails. The ones that are highly novel are propagated to the next generation. As shown in \tableref{iteration_2_methodology_table}, there are 28 distance calculations in total. Now, we try to generalize the pattern observed in these iterations to calculate the overall runtime of the algorithm.

\begin{table}[htbp]
\begin{center}
\caption{Calculation of distances in $2^{nd}$ iteration}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
\hline
 & \textbf{A} & \textbf{B} & \textbf{C} & \textbf{D} & \textbf{E} & \textbf{F} & \textbf{G} & \textbf{H} & \textbf{Total} \\
\hline
\textbf{A} &  & $Dist_{1}$ & $Dist_{2}$ & $Dist_{3}$ & $Dist_{7}$ & $Dist_{8}$ & $Dist_{9}$ & $Dist_{10}$ & 7 \\
\hline
\textbf{B} &  &  & $Dist_{4}$ & $Dist_{5}$ & $Dist_{11}$ & $Dist_{12}$ & $Dist_{13}$ & $Dist_{14}$ & 6 \\
\hline
\textbf{C} &  &  &  & $Dist_{6}$ & $Dist_{15}$ & $Dist_{16}$ & $Dist_{17}$ & $Dist_{18}$ & 5 \\
\hline
\textbf{D} &  &  &  &   & $Dist_{19}$ & $Dist_{20}$ & $Dist_{21}$ & $Dist_{22}$ & 4 \\
\hline
\textbf{E} &  &  &  &   & & $Dist_{23}$ & $Dist_{24}$ & $Dist_{25}$ & 3 \\
\hline
\textbf{F} &  &  &  &   &  & & $Dist_{26}$ & $Dist_{27}$ & 2 \\
\hline
\textbf{G} &  &  &  &   & & &  & $Dist_{28}$ & 1 \\
\hline
\textbf{H} &  &  &  &   & & & & & 0 \\
\hline
\textbf{Total} & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 28 \\
\hline
\end{tabular}
\label{iteration_2_methodology_table}
\end{center}
\end{table}



The complexity of this algorithm can be analyzed with respect to population size, $p$, and the number of iterations, $i$.
%Let us run the algorithm with population size of $p$ for $i$ iteration. 
The total number of cocktails will be $p*i$. By analyzing  \tableref{iteration_2_methodology_table}, the total number of distance calculations required can be computed as:

\begin{equation}
D = 1 + 2 + ... + (p*i - 1) =\frac{(p*i - 1)(p*i)}{2}\label{eq}
\end{equation}

%\begin{equation}
%D = \frac{(p*i - 1)(p*i)}{2} \label{eq}
%\end{equation}

As shown in \tableref{iteration_2_methodology_table2}, each distance computation requires computation of two feature vectors, one for each cocktail.
The number of computations required can be determined as:
%Now, we incorporate the calculation of feature vectors of cocktails and chemicals in our runtime calculation.

\begin{equation}
D_f = 2 * \frac{(p*i - 1)(p*i)}{2} \label{eq}
\end{equation}


\begin{table}[htbp]
\begin{center}
\caption{Calculation of feature vectors in 2nd Iteration}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
\hline
 & \textbf{A} & \textbf{B} & \textbf{C} & \textbf{D} & \textbf{E} & \textbf{F} & \textbf{G} & \textbf{H} & \textbf{Total} \\
\hline
\textbf{A} &  & $F_{A}$, $F_{B}$ & $F_{A}$, $F_{C}$ & $F_{A}$, $F_{D}$ & $F_{A}$, $F_{E}$ & $F_{A}$, $F_{F}$ & $F_{A}$, $F_{G}$ & $F_{A}$, $F_{H}$  & 14 \\
\hline
\textbf{B} &  &  & $F_{B}$, $F_{C}$ & $F_{B}$, $F_{D}$ & $F_{B}$, $F_{E}$  & $F_{B}$, $F_{F}$  & $F_{B}$, $F_{G}$  & $F_{B}$, $F_{H}$  & 12 \\
\hline
\textbf{C} &  &  &  & $F_{C}$, $F_{D}$ & $F_{C}$, $F_{E}$  & $F_{C}$, $F_{F}$  & $F_{C}$, $F_{G}$  & $F_{C}$, $F_{H}$  & 10 \\
\hline
\textbf{D} &  &  &  &   & $F_{D}$, $F_{E}$  & $F_{D}$, $F_{F}$  & $F_{D}$, $F_{G}$  & $F_{D}$, $F_{H}$  & 8 \\
\hline
\textbf{E} &  &  &  &   & & $F_{E}$, $F_{F}$  & $F_{E}$, $F_{G}$  & $F_{E}$, $F_{H}$  & 6 \\
\hline
\textbf{F} &  &  &  &   &  & & $F_{F}$, $F_{G}$  & $F_{F}$, $F_{H}$  & 4 \\
\hline
\textbf{G} &  &  &  &   & & &  & $F_{G}$, $F_{H}$  & 2 \\
\hline
\textbf{H} &  &  &  &   & & & & & 0 \\
\hline
\textbf{Total} & 0 & 2 & 4 & 6 & 8 & 10 & 12 & 14 & 56 \\
\hline
\end{tabular}
\label{iteration_2_methodology_table2}
\end{center}
\end{table}

%As shown in \tableref{iteration_2_methodology_table2}, we compute the feature vectors $F_{A}$ and $F_{B}$ of cocktails A and B respectively while calculating $Dist_{1}$. Similarly, feature vectors $F_{A}$ and $F_{C}$ are calculated for $Dist_{2}$. We repeat this process for all distances.

%We notice that 2 feature vectors are involved in the calculation of distance. So, the runtime becomes:


As mentioned earlier, the feature vector of a cocktail depends on the vectors of the chemicals it is composed of. 
%in turn depends on the feature vectors of the chemicals it is composed of. 
Since the number of vectors of chemicals depend on the gene length ($g$), the number of computations needed for finding vectors of all chemicals can be represented as:
%These are represented as $f_{A_{P}}$ and $f_{A_{S}}$. Finally, the runtime becomes:

\begin{equation}
D_{fc} = g * 2* (p*i - 1)(p*i) \label{eq}
\end{equation}

\noindent
where $g$ is the gene length. In our case, we only compute the vectors for salts and precipitants (which would be equivalent to $g-1$).

The overall complexity of the algorithm before optimization could be stated as $O ( g * p^2 * i^2 )$
%Hence, the running time in Big-O notation is given by:
%\begin{equation}
%O ( g * p^2 * i^2 ) \label{eq}
%\end{equation}
where $g$ is the gene length, $p$ is the population size, and $i$ is the total number of iterations of the algorithm.

This was the initial version of the algorithm that achieved novelty search. We had performed this analysis to determine the overhead of computations. Next, we discuss how to optimize the algorithm to reduce  
the running time by reusing the feature vectors of chemicals and cocktails. 
%This is well explained in the next subsections.


\subsection{Optimization by building a dictionary of chemicals}\label{sec:GA-runtime-reappear-chemicals}

%As mentioned in the previous section, we need to calculate the feature vector of chemicals to calculate the distance between two cocktails.
Our observation is that if a chemical is present in one cocktail, there is a highly likelihood of it appearing in some other cocktails as well. Furthermore, there is a fixed number of chemicals that are used in forming cocktails in our experiments. So, we computed the feature vector for every chemical we had and stored it in a file to be retrieved later.
%the algorithm can just load it and retrieve the feature vector of any chemical.

%Show statistics of chemicals reuse

The vectors are stored in Python's $dictionary$ data structure. It is equivalent to associative array with keys as the names of the chemicals and values as the feature vectors. The retrieval time of a $dictionary$ is in $O(1)$. This gets rid of the $g$ factor from the complexity. Hence the overall time complexity becomes
%\begin{equation}
$O ( p^2 * i^2 )$.%  \label{eq}
%\end{equation}



\subsection{Optimization of the overlapping cocktails}\label{sec:GA-runtime-overlap-cocktails}

After reducing the time complexity by using precalculated feature vectors of all chemicals, we consider whether any optimization could be achieved on computation of feature vectors of cocktails. %computation go ahead and optimize the cocktails. 
\tableref{iteration_2_methodology_table2} has feature vector computations for two iterations of cocktails. The genetic algorithm does not guarantee that the cocktails in new generations will always be different from previous cocktails. In other words, in \tableref{iteration_2_methodology_table2}, A, B, C, D, E, F, G, and H may not be different from each other.
So it is possible that the cocktails that appear in one iteration can reappear in future iterations. In other words, the number of unique cocktails (cocktails that were never seen by the algorithm)  decreases every iteration. This also implies that the genetic algorithm converges by not being able to generate unique individuals (cocktails). To analyze this, we plot the total number of unique intermediate cocktails for each generation (\figureref{fig:unique-intermediates}) using the $population\_size$ of 200. The plot also shows how the number of unique cocktails decreases based on different mutation rates. When we apply regression analysis for the number of unique cocktails for $mutation\_rate = 0.5$, the total number of unique intermediate cocktails for $k^{th}$ ($k \geq 1$) generation is approximately given by

\begin{equation}
U(k) = 148 - 22 ln(k)  \label{eq}
\end{equation}
%We then try different values of mutation to further prove our assumption. The plot is shown below:

The integral of the equation can be used to approximate  the total number of unique cocktails ever encountered by the algorithm as follows:

\begin{equation}
\int (148 - 22 ln(k))dk = 170 k - 22 kln(k)  \label{eq}
\end{equation}

\begin{figure}[H]
	\cfig{2}{chart.png}{5}
	\caption{\# of Generations vs \# of Unique Intermediate Cocktails}
	\label{fig:unique-intermediates}
\end{figure}

This shows that there is a significant number of overlapping cocktails, thereby hints that the algorithm may further be optimized by reusing feature vectors of cocktails that already appeared. Similarly as for chemicals, to store a cocktail, we use Python's $dictionary$ data structure with key as the concatenation of the name of its chemicals and the value as its feature vector.

%a method to reuse the feature vectors of cocktails already seen by the algorithm. For $mutation\_rate = 0.5$, the total number of unique intermediate cocktails for $k$th generation is given by:

%\begin{equation}
%U(k) = 147.847 - 21.874 ln(k)  \label{eq}
%\end{equation}


%\subsection{Time complexity after optimization}\label{sec:GA-runtime-final-bigO}

After making these optimizations, it is not necessary to recompute the feature vectors of cocktails already encountered. 
This means, that for each cocktail, its vector needs to be calculated only once.
The time complexity which was quadratically dependent on the total number of cocktails $O ( (p * i)^2 )$  is still the same. But assuming that the $population\_size$ is fixed to $200$ and $iteration=k$, the total number of cocktails will be approximately $170k - 22kln(k)$ instead of $200*k$. Hence, the running time is roughly improved by a factor of 

\begin{equation}
\left(\frac{200k}{170k - 22kln(k)}\right)^2  \label{eq}
\end{equation}

\begin{equation}
= \left(\frac{200}{170 - 22ln(k)}\right)^2  \label{eq}
\end{equation}

%The graph for this equation is shown in \figureref{fig:factor}. 
This indicates that the runtime could be improved by a factor of around $27$ when the algorithm is run for 400 iterations.

%\begin{figure}[H]
%	\cfig{2}{factor.png}{5}
%	\caption{\# of Generations vs Factor}
%	\label{fig:factor}
%\end{figure}
%\begin{equation}
%$O ( p * i )$  \label{eq}
%\end{equation}

\section{Summary} \label{rel:summary}

In this chapter, we explained the methodology of implementing novelty search for generating crystalline conditions. We described the required modifications to be made in the fitness function. We then described an appropriate distance measure for calculating the distance between two cocktails. Furthermore, we explained how we were able to reduce the redundancies involved in evaluation of individuals across generations.
